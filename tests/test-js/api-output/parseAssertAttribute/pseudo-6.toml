instructions = [
  """let parseAssertElemAttr = await page.$$(\"a ::after\");
if (parseAssertElemAttr.length === 0) { throw '\"a ::after\" not found'; }
for (let i = 0, len = parseAssertElemAttr.length; i < len; ++i) {
    await page.evaluate(e => {
        const nonMatchingAttrs = [];
        const parseAssertElemAttrDict = {\"a\":\"1\"};
        const nullAttributes = [];
        for (const attr of nullAttributes) {
            if (e.hasAttribute(attr)) {
                nonMatchingAttrs.push(\"Expected attribute `\" + attr + \"` to not exist, found: `\" + e.getAttribute(attr) + \"`\");
                continue;
            }
        }
        for (const [parseAssertElemAttrAttribute, parseAssertElemAttrValue] of Object.entries(parseAssertElemAttrDict)) {
            if (!e.hasAttribute(parseAssertElemAttrAttribute)) {
                nonMatchingAttrs.push(\"No attribute named `\" + parseAssertElemAttrAttribute + \"`\");
                continue;
            }
            const attr = e.getAttribute(parseAssertElemAttrAttribute);
            if (attr !== parseAssertElemAttrValue) {
                nonMatchingAttrs.push(\"attribute `\" + parseAssertElemAttrAttribute + \"` isn't equal to `\" + parseAssertElemAttrValue + \"` (`\" + attr + \"`)\");
            }
        }
        if (nonMatchingAttrs.length !== 0) {
            const props = nonMatchingAttrs.join(\", \");
            throw \"The following errors happened (for selector `a ::after`): [\" + props + \"]\";
        }
    }, parseAssertElemAttr[i]);
}""",
]
wait = false
warnings = [
]
checkResult = true
