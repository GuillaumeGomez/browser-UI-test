{
  "instructions": [
    "let parseAssertElemAttr = await page.$x(\"//a\");\nif (parseAssertElemAttr.length === 0) { throw 'XPath \"//a\" not found'; }\nfor (let i = 0, len = parseAssertElemAttr.length; i < len; ++i) {\n    await page.evaluate(e => {\n        const nonMatchingAttrs = [];\n        const parseAssertElemAttrDict = {\"b\":\"c\"};\n        const nullAttributes = [];\n        for (const attr of nullAttributes) {\n            if (e.hasAttribute(attr)) {\n                continue;\n            }\n            nonMatchingAttrs.push(\"Attribute named `\" + attr + \"` doesn't exist\");\n        }\n        for (const [parseAssertElemAttrAttribute, parseAssertElemAttrValue] of Object.entries(parseAssertElemAttrDict)) {\n            if (!e.hasAttribute(parseAssertElemAttrAttribute)) {\n                continue;\n            }\n            const attr = e.getAttribute(parseAssertElemAttrAttribute);\n            if (attr === parseAssertElemAttrValue) {\n                nonMatchingAttrs.push(\"assert didn't fail for attribute `\" + parseAssertElemAttrAttribute + \"` (`\" + attr + \"`)\");\n            }\n        }\n        if (nonMatchingAttrs.length !== 0) {\n            const props = nonMatchingAttrs.join(\", \");\n            throw \"The following errors happened (for XPath `//a`): [\" + props + \"]\";\n        }\n    }, parseAssertElemAttr[i]);\n}"
  ],
  "wait": false,
  "warnings": [],
  "checkResult": true
}
