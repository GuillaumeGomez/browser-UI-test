{
  "instructions": [
    "let parseAssertElemAttr = await page.$$(\"a\");\nif (parseAssertElemAttr.length === 0) { throw '\"a\" not found'; }\nfor (let i = 0, len = parseAssertElemAttr.length; i < len; ++i) {\n    await page.evaluate(e => {\n        const nonMatchingAttrs = [];\n        const parseAssertElemAttrDict = {\"a\":\"c\"};\n        const nullAttributes = [\"\\\"b\"];\n        for (const attr of nullAttributes) {\n            if (e.hasAttribute(attr)) {\n                continue;\n            }\n            nonMatchingAttrs.push(\"Attribute named `\" + attr + \"` doesn't exist\");\n        }\n        for (const [parseAssertElemAttrAttribute, parseAssertElemAttrValue] of Object.entries(parseAssertElemAttrDict)) {\n            if (!e.hasAttribute(parseAssertElemAttrAttribute)) {\n                continue;\n            }\n            const attr = e.getAttribute(parseAssertElemAttrAttribute);\n            if (attr.indexOf(parseAssertElemAttrValue) !== -1) {\n                nonMatchingAttrs.push(\"assert didn't fail for attribute `\" + parseAssertElemAttrAttribute + \"` (`\" + attr + \"`) (for CONTAINS check)\");\n            }\n            if (attr.startsWith(parseAssertElemAttrValue)) {\n                nonMatchingAttrs.push(\"assert didn't fail for attribute `\" + parseAssertElemAttrAttribute + \"` (`\" + attr + \"`) (for STARTS_WITH check)\");\n            }\n        }\n        if (nonMatchingAttrs.length !== 0) {\n            const props = nonMatchingAttrs.join(\", \");\n            throw \"The following errors happened (for selector `a`): [\" + props + \"]\";\n        }\n    }, parseAssertElemAttr[i]);\n}"
  ],
  "wait": false,
  "warnings": [
    "Special checks (CONTAINS, STARTS_WITH) will be ignored for `null`"
  ],
  "checkResult": true
}
