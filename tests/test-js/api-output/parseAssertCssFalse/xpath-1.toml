instructions = [
  """let parseAssertElemCss = await page.$x(\"//a\");
if (parseAssertElemCss.length === 0) { throw 'XPath \"//a\" not found'; }
parseAssertElemCss = parseAssertElemCss[0];
await page.evaluate(e => {
    const nonMatchingProps = [];
    let assertComputedStyle = getComputedStyle(e);
    const parseAssertElemCssDict = {};
    for (const [parseAssertElemCssKey, parseAssertElemCssValue] of Object.entries(parseAssertElemCssDict)) {
        const localErr = [];
        let succeeded = false;
        if (e.style[parseAssertElemCssKey] != parseAssertElemCssValue && assertComputedStyle[parseAssertElemCssKey] != parseAssertElemCssValue) {
            if (typeof assertComputedStyle[parseAssertElemCssKey] === \"string\" && assertComputedStyle[parseAssertElemCssKey].search(/^(\\d+\\.\\d+px)$/g) === 0) {
                if (browserUiTestHelpers.extractFloatOrZero(assertComputedStyle[parseAssertElemCssKey], true) + \"px\" !== parseAssertElemCssValue) {
                    localErr.push('expected `' + parseAssertElemCssValue + '` for key `' + parseAssertElemCssKey + '`, found `' + assertComputedStyle[parseAssertElemCssKey] + '` (or `' + browserUiTestHelpers.extractFloatOrZero(assertComputedStyle[parseAssertElemCssKey], true) + 'px`)');
                }
                succeeded = true;
            }
            if (!succeeded) {
                localErr.push('expected `' + parseAssertElemCssValue + '` for key `' + parseAssertElemCssKey + '`, found `' + assertComputedStyle[parseAssertElemCssKey] + '`');
            }
        }
        if (localErr.length === 0) {
            nonMatchingProps.push(\"assert didn't fail for key `\" + parseAssertElemCssKey + '`');
        }
    }
    if (nonMatchingProps.length !== 0) {
        const props = nonMatchingProps.join(\", \");
        throw \"The following errors happened (for XPath `//a`): [\" + props + \"]\";
    }
}, parseAssertElemCss);""",
]
wait = false
warnings = [
]
checkResult = true
