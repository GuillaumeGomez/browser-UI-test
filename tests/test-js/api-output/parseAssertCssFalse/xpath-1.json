{
  "instructions": [
    "let parseAssertElemCss = await page.$x(\"//a\");\nif (parseAssertElemCss.length === 0) { throw 'XPath \"//a\" not found'; }\nparseAssertElemCss = parseAssertElemCss[0];\nawait page.evaluate(e => {\n    const nonMatchingProps = [];\n    let assertComputedStyle = getComputedStyle(e);\n    const parseAssertElemCssDict = {};\n    for (const [parseAssertElemCssKey, parseAssertElemCssValue] of Object.entries(parseAssertElemCssDict)) {\n        const localErr = [];\n        let succeeded = false;\n        if (e.style[parseAssertElemCssKey] != parseAssertElemCssValue && assertComputedStyle[parseAssertElemCssKey] != parseAssertElemCssValue) {\n            if (typeof assertComputedStyle[parseAssertElemCssKey] === \"string\" && assertComputedStyle[parseAssertElemCssKey].search(/^(\\d+\\.\\d+px)$/g) === 0) {\n                if (browserUiTestHelpers.extractFloatOrZero(assertComputedStyle[parseAssertElemCssKey], true) + \"px\" !== parseAssertElemCssValue) {\n                    localErr.push('expected `' + parseAssertElemCssValue + '` for key `' + parseAssertElemCssKey + '`, found `' + assertComputedStyle[parseAssertElemCssKey] + '` (or `' + browserUiTestHelpers.extractFloatOrZero(assertComputedStyle[parseAssertElemCssKey], true) + 'px`)');\n                }\n                succeeded = true;\n            }\n            if (!succeeded) {\n                localErr.push('expected `' + parseAssertElemCssValue + '` for key `' + parseAssertElemCssKey + '`, found `' + assertComputedStyle[parseAssertElemCssKey] + '`');\n            }\n        }\n        if (localErr.length === 0) {\n            nonMatchingProps.push(\"assert didn't fail for key `\" + parseAssertElemCssKey + '`');\n        }\n    }\n    if (nonMatchingProps.length !== 0) {\n        const props = nonMatchingProps.join(\", \");\n        throw \"The following errors happened (for XPath `//a`): [\" + props + \"]\";\n    }\n}, parseAssertElemCss);"
  ],
  "wait": false,
  "warnings": [],
  "checkResult": true
}
