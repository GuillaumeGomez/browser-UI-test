instructions = [
  """const timeLimit = page.getDefaultTimeout();
const timeAdd = 50;
let allTime = 0;
let parseWaitForText = null;
async function checkTextForElem(elem) {
    return await elem.evaluate(e => {
        const value = \"b\";
        const elemText = browserUiTestHelpers.getElemText(e, value);
        const errors = [];
    if (elemText !== value) {
        errors.push(\"`\" + elemText + \"` isn't equal to `\" + value + \"`\");
    }
        if (errors.length !== 0) {
            const errs = errors.join(\", \");
            throw \"The following errors happened: [\" + errs + \"]\";
        }
    });
}
const value = \"b\";
let computedEntry;
while (true) {
    while (true) {
        parseWaitForText = await page.$(\"a\");
        if (parseWaitForText !== null) {
            break;
        }
        await new Promise(r => setTimeout(r, timeAdd));
        if (timeLimit === 0) {
            continue;
        }
        allTime += timeAdd;
        if (allTime >= timeLimit) {
            throw new Error(\"The following CSS selector \\\"a\\\" was not found\");
        }
    }
    computedEntry = await page.evaluate(e => {
        return browserUiTestHelpers.getElemText(e, \"b\");
    }, parseWaitForText);
    if (computedEntry === value) {
        break;
    }
    await new Promise(r => setTimeout(r, timeAdd));
    if (timeLimit === 0) {
        continue;
    }
    allTime += timeAdd;
    if (allTime >= timeLimit) {
        throw new Error(\"The text still doesn't match: `\" + computedEntry + \"` != `\" + value + \"`\");
    }
}""",
]
wait = false
warnings = [
  """Pseudo-elements (`::after`) don't have inner text so the check will be performed on the element itself""",
]
checkResult = true
