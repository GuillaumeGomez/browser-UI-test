instructions = [
  """let parseCompareElementsProp1 = await page.$x(\"//a\");
if (parseCompareElementsProp1.length === 0) { throw 'XPath \"//a\" not found'; }
parseCompareElementsProp1 = parseCompareElementsProp1[0];
let parseCompareElementsProp2 = await page.$(\"b\");
if (parseCompareElementsProp2 === null) { throw '\"b\" not found'; }
const parseCompareElementsProps = [[\"margin\"]];
for (const property of parseCompareElementsProps) {
    const value = await parseCompareElementsProp1.evaluateHandle((e, p) => {
        function checkObjectPaths(object, path, callback, notFoundCallback) {
            const found = [];

            for (const subPath of path) {
                found.push(subPath);
                if (object === undefined || object === null) {
                    notFoundCallback(found);
                    return;
                }
                object = object[subPath];
            }
            callback(object);
        }
        let ret = 'undefined';
        checkObjectPaths(e, p, found => ret = String(found), notFound => {});
        return ret;
    }, property);
    await parseCompareElementsProp2.evaluate((e, v, p) => {
        function checkObjectPaths(object, path, callback, notFoundCallback) {
            const found = [];

            for (const subPath of path) {
                found.push(subPath);
                if (object === undefined || object === null) {
                    notFoundCallback(found);
                    return;
                }
                object = object[subPath];
            }
            callback(object);
        }
        let ret = 'undefined';
        checkObjectPaths(e, p, found => ret = String(found), notFound => {});
        if (v !== ret) {
            throw p + \": `\" + v + \"` !== `\" + ret + \"`\";
        }
    }, value, property);
}""",
]
wait = false
checkResult = true
