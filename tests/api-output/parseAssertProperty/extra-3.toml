instructions = [
  """let parseAssertElemProp = await page.$(\"a\");
if (parseAssertElemProp === null) { throw '\"a\" not found'; }
await page.evaluate(e => {
    function checkObjectPaths(object, path, callback, notFoundCallback) {
        const found = [];

        for (const subPath of path) {
            found.push(subPath);
            if (object === undefined || object === null) {
                notFoundCallback(found);
                return;
            }
            object = object[subPath];
        }
        callback(object);
    }

    const nonMatchingProps = [];
    const parseAssertElemPropDict = [[[\"a\"],\"1\"]];
    const undefProps = [];
    for (const prop of undefProps) {
        checkObjectPaths(e, prop, val => {
            if (val !== undefined && val !== null) {
                const p = prop.map(p => `\"${p}\"`).join('.');
                nonMatchingProps.push(\"Expected property `\" + p + \"` to not exist, found: `\" + val + \"`\");
                return;
            }

        }, prop => {

        });
    }
    for (const [parseAssertElemPropKey, parseAssertElemPropValue] of parseAssertElemPropDict) {
        checkObjectPaths(e, parseAssertElemPropKey, val => {
            if (val === undefined && val === null) {                const p = parseAssertElemPropKey.map(p => `\"${p}\"`).join('.');
                nonMatchingProps.push('Unknown property `' + parseAssertElemPropKey + '`');

                return;
            }
            const prop = String(val);
            if (!prop.startsWith(parseAssertElemPropValue)) {
                nonMatchingProps.push(\"property `\" + parseAssertElemPropKey.map(p => `\"${p}\"`).join('.') + \"` (`\" + prop + \"`) doesn't start with `\" + parseAssertElemPropValue + \"` (for STARTS_WITH check)\");
            }
            if (!prop.endsWith(parseAssertElemPropValue)) {
                nonMatchingProps.push(\"property `\" + parseAssertElemPropKey.map(p => `\"${p}\"`).join('.') + \"` (`\" + prop + \"`) doesn't end with `\" + parseAssertElemPropValue + \"`\");
            }
        }, parseAssertElemPropKey => {
            const p = parseAssertElemPropKey.map(p => `\"${p}\"`).join('.');
            nonMatchingProps.push('Unknown property `' + parseAssertElemPropKey + '`');
});
    }
    if (nonMatchingProps.length !== 0) {
        const props = nonMatchingProps.join(\"; \");
        throw \"The following errors happened (for selector `a`): [\" + props + \"]\";
    }
}, parseAssertElemProp);""",
]
wait = false
warnings = [
]
checkResult = true
